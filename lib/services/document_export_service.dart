import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:file_picker/file_picker.dart';
import 'package:html/parser.dart' as html_parser;
import '../models/document.dart';

enum ExportFormat {
  pdf,
  doc,
  rtf,
  txt,
  html
}

class DocumentExportService {
  static Future<void> exportDocument(
    PolicyDocument document,
    ExportFormat format, {
    String? customFileName,
  }) async {
    final fileName = customFileName ?? '${document.title}.${format.name}';
    String content;

    switch (format) {
      case ExportFormat.pdf:
        final pdf = await _createPdf(document);
        final bytes = await pdf.save();
        await _saveBytes(bytes, fileName);
        return;
      case ExportFormat.doc:
        content = await _createDoc(document);
        break;
      case ExportFormat.rtf:
        content = await _createRtf(document);
        break;
      case ExportFormat.txt:
        content = await _createTxt(document);
        break;
      case ExportFormat.html:
        content = await _createHtml(document);
        break;
    }

    await _saveFile(content, fileName);
  }

  static Future<pw.Document> _createPdf(PolicyDocument document) async {
    final pdf = pw.Document();

    // Create PDF content
    pdf.addPage(
      pw.Page(
        pageFormat: PdfPageFormat.a4,
        build: (context) {
          return pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              pw.Header(
                level: 0,
                child: pw.Text(
                  document.title,
                  style: pw.TextStyle(
                    fontSize: 24,
                    fontWeight: pw.FontWeight.bold,
                  ),
                ),
              ),
              pw.SizedBox(height: 20),
              pw.Text(_stripHtml(document.content ?? '')),
              pw.SizedBox(height: 20),
              pw.Divider(),
              pw.SizedBox(height: 10),
              pw.Text(
                'Generated by PolicyForge AI',
                style: const pw.TextStyle(
                  fontSize: 8,
                  color: PdfColors.grey,
                ),
              ),
            ],
          );
        },
      ),
    );

    return pdf;
  }

  static Future<String> _createDoc(PolicyDocument document) async {
    // Create a simple HTML-like format that Word can open
    return '''
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>${document.title}</title>
</head>
<body>
<h1>${document.title}</h1>
${document.content ?? ''}
<hr>
<p style="color: gray; font-size: 8pt;">Generated by PolicyForge AI</p>
</body>
</html>
''';
  }

  static Future<String> _createRtf(PolicyDocument document) async {
    // Basic RTF format
    return '''{\\rtf1\\ansi\\deff0
{\\fonttbl{\\f0\\froman Times New Roman;}}
{\\colortbl;\\red0\\green0\\blue0;}
{\\info{\\title ${_escapeRtf(document.title)}}}
\\viewkind4\\uc1\\pard\\f0\\fs24
{\\b\\fs48 ${_escapeRtf(document.title)}}\\par
\\par
${_escapeRtf(_stripHtml(document.content ?? ''))}\\par
\\par
{\\i\\fs16 Generated by PolicyForge AI}
}''';
  }

  static Future<String> _createTxt(PolicyDocument document) async {
    return '''${document.title}

${_stripHtml(document.content ?? '')}

Generated by PolicyForge AI''';
  }

  static Future<String> _createHtml(PolicyDocument document) async {
    return '''
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${document.title}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .footer {
            margin-top: 40px;
            padding-top: 10px;
            border-top: 1px solid #eee;
            color: #666;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>${document.title}</h1>
    ${document.content ?? ''}
    <div class="footer">Generated by PolicyForge AI</div>
</body>
</html>''';
  }

  static String _stripHtml(String html) {
    final document = html_parser.parse(html);
    return document.body?.text ?? html;
  }

  static String _escapeRtf(String text) {
    return text
        .replaceAll('\\', '\\\\')
        .replaceAll('{', '\\{')
        .replaceAll('}', '\\}')
        .replaceAll('\n', '\\par ');
  }

  static Future<void> _saveFile(String content, String fileName) async {
    final result = await FilePicker.platform.saveFile(
      dialogTitle: 'Export Document',
      fileName: fileName,
      allowedExtensions: [fileName.split('.').last],
      type: FileType.custom,
    );

    if (result != null) {
      await writeFile(result, content);
    }
  }

  static Future<void> _saveBytes(List<int> bytes, String fileName) async {
    final result = await FilePicker.platform.saveFile(
      dialogTitle: 'Export Document',
      fileName: fileName,
      allowedExtensions: [fileName.split('.').last],
      type: FileType.custom,
    );

    if (result != null) {
      await writeBinaryFile(result, bytes);
    }
  }

  static Future<void> writeFile(String path, String content) async {
    try {
      // Platform-specific file writing implementation
      throw UnimplementedError('Platform-specific implementation required');
    } catch (e) {
      throw Exception('Failed to write file: $e');
    }
  }

  static Future<void> writeBinaryFile(String path, List<int> bytes) async {
    try {
      // Platform-specific binary file writing implementation
      throw UnimplementedError('Platform-specific implementation required');
    } catch (e) {
      throw Exception('Failed to write binary file: $e');
    }
  }
}
